<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Index</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Index</h1>

    


    


    <h3> </h3>









    




    <section>
        <article><h1>Hierarchial State Machine for Javascript</h1><p><a href="https://travis-ci.org/Mask/hsm-js"><img src="https://travis-ci.org/Mask/hsm-js.png" alt="Build Status"></a> <a href="http://mask.github.io/hsm-js/HSM.html">API docs</a></p>
<h2>Description</h2><p>Simple, yet powerful hierarchial state machine framework. Supports Sub-Statemachines (nested states) and Parallel-Statemachines (orthogonal regions) and entry and exit handlers.  </p>
<p>The following state machine is used <a href="test/testAdvanced.js">in the tests</a> and this documentation to illustrate the features.</p>
<p><img src="doc/advanced.png" alt="advanced state machine example" title="advanced state machine example"></p>
<h2>States and State Machines</h2><p>States are specified by creating HSM.State instances. They are then composed to a state machine by passing them to the HSM.StateMachine constructor.</p>
<pre class="prettyprint source"><code>    var a1 = new HSM.State(&quot;a1&quot;);
    var a2 = new HSM.State(&quot;a2&quot;);
    var a3 = new HSM.State(&quot;a3&quot;);
    var a = new HSM.StateMachine([a1,a2,a3]);</code></pre><p>By convention, the first state passed is the initial state. The state machine is then initialized by HSM.StateMachine.init():</p>
<pre class="prettyprint source"><code>    a.init();</code></pre><p>This starts the state machine and activates the initial state, calling its entry handler (see below). The state machine is now ready to 
handle events.</p>
<h2>Actions and State Transitions</h2><p>Each state has a map of event handlers. These handlers will be called when the state receives the respective event.
Event handlers are added to the handler[] array of each state:</p>
<pre class="prettyprint source"><code>a3.handler['T3'] = { target: a1 };</code></pre><p>This specifies a transition from State to newState for event. Additionally, an action can be added to the transition:</p>
<pre class="prettyprint source"><code>a2.handler['T2'] = { target: a3, action: function() { this.emit('T3') };</code></pre><p>Events are triggered by calling the StateMachine.handleEvent() method. This can even be done inside an event handler's actionFunc.  If an event is 
triggered while an event is being handled it will be queued until the current event completes. This is known as the run-to-completion (RTC) execution model.  </p>
<h2>Guards</h2><p>Guards (or guard conditions) affect the behaviour of a state machine by enabling actions or transitions only when they evaluate to TRUE and disabling them when they evaluate to FALSE. 
When using guards, multiple event handlers can be bound to a single trigger with a guard. Each guard is evaluated until one returns true. The respective handler is then invoked (after calling
the usual exit handler).</p>
<pre class="prettyprint source"><code>    a1.handler.T1 = [
        { target: a2, guard: function (_,_,data) { return data==true; } },
        { target: a3, guard: function (_,_,data) { return data==false; } }
    ];</code></pre><h2>Entry and Exit handlers</h2><p>Each state can have a <code>on_entry</code> and/or <code>on_exit</code> function. They will be invoked when the state is entered or exited. </p>
<h2>Sub-StateMachines (nested)</h2><p>State Machines can be nested in other state machines my using the HSM.Sub adapter class. All events are propgated into the sub-state machines, 
and the sub state machine is initialized and torn down on entry/exit of its containing state.</p>
<pre class="prettyprint source"><code>    var a1 = new HSM.State(&quot;a1&quot;);
    var a2 = new HSM.State(&quot;a2&quot;);
    var a3 = new HSM.State(&quot;a3&quot;);

    var a = new HSM.Sub(&quot;a&quot;, new HSM.StateMachine([a1, a2, a3]));</code></pre><p>Since <em>a</em> is a State it can be used to construct the <em>top</em> state machine, can have event handlers and entry and exit handlers.</p>
<h2>Lowest Common Ancestor Algorithm</h2><p>A transition can span nested state machines. In the case, the transition is performed by the lowest common ancestor (LCA) of the
source and target transition. All exit handlers from the source transition up to (but not including) the LCA are called, the transition action is
called, then all entry handlers from the LCA down to the target state are called. Note that the initial states of these targeted state machines are not 
entered - the explict target state path is used instead. If the target state is itself composite, it's nested states will be initialized in
the normal manner (with their respective initial states).</p>
<p>For example. T4 will fire <code>a3:on_exit, a:on_exit</code>, exiting up to the LCA, then <code>b:on_entry, b2:on_entry</code> entering to the target,
followed by <code>b21:on_entry</code> since it is the initial state of <code>b2</code>. </p>
<h2>Parallel State-Machines (orthogonal regions)</h2><p>Parallel state machines are constructed with the HSM.Parallel adapter class.</p>
<pre class="prettyprint source"><code>    var c11 = new HSM.State(&quot;c11&quot;);
    var c12 = new HSM.State(&quot;c12&quot;);

    var c21 = new HSM.State(&quot;c21&quot;);
    var c22 = new HSM.State(&quot;c22&quot;);

    var c = new HSM.Parallel(&quot;c&quot;, new HSM.StateMachine([c11, c12]), 
                                  new HSM.StateMachine([c21, c22]));</code></pre><p>again, <em>c</em> is a State and can be used to construct the <em>top</em> state machine. It can have event handlers and entry and exit handlers.</p>
<h2>Internal, External and Local Transitions (TODO)</h2></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="HSM.Parallel.html">Parallel</a></li><li><a href="HSM.State.html">State</a></li><li><a href="HSM.StateMachine.html">StateMachine</a></li><li><a href="HSM.Sub.html">Sub</a></li></ul><h3>Namespaces</h3><ul><li><a href="HSM.html">HSM</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha9</a> on Wed Sep 03 2014 22:54:32 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>